//------------------------------------------------
//--- 010 Editor v9.0.2 Binary Template
//
//      File: MHW_MOD3.bt
//   Authors: 诸葛不太亮(korone)
//   Version: 1.2
//   Purpose: MHW MOD3 File Editing
//  Category: MHW MOD3
// File Mask: *.mod3*
//  ID Bytes: 4D 4F 44 00
//   History: September 13, 2025      
//------------------------------------------------
LittleEndian();

local int i <hidden=true>, j <hidden=true>, k <hidden=true>, m <hidden=true>;
local int oriOffset <hidden=true>;
local int validMeshCount <hidden=true> = 0;
const float scale = 0.0078125;
const float weightScale = 1.0/1023;

struct Sphere{
    float x;
    float y;
    float z;
    float r;
};
string readSphere(Sphere &sph){
    string s;
    SPrintf( s, "x: %6.2f    y: %6.2f    z: %6.2f    r: %6.2f", 
            sph.x, sph.y, sph.z, sph.r);
    return s;
}
struct Box{
    float min_x;
    float min_y;
    float min_z;
    float min_0;
    float max_x;
    float max_y;
    float max_z;
    float max_0;
};
string readBox(Box &box){
    string s;
    SPrintf( s, "min: %6.2f, %6.2f, %6.2f,   max: %6.2f, %6.2f, %6.2f", 
            box.min_x, box.min_y, box.min_z, box.max_x, box.max_y, box.max_z);
    return s;
}
struct Vec3{
    float x;
    float y;
    float z;
};
string readVec3(Vec3 &vec3){
    string s;
    SPrintf( s, "x: %6.2f    y: %6.2f    z: %6.2f", 
            vec3.x, vec3.y, vec3.z);
    return s;
}
struct Vec4{
    float x;
    float y;
    float z;
    float w;
};
string readVec4(Vec4 &vec4){
    string s;
    SPrintf( s, "x: %6.2f    y: %6.2f    z: %6.2f    w: %6.2f", 
            vec4.x, vec4.y, vec4.z, vec4.w);
    return s;
}
struct UV{
    hfloat x;
    hfloat y;
};
string readNorTan(byte x){
    string s;
    SPrintf( s, "%f    raw: %d", x*scale, x);
    return s;
}
struct NorTan{
    byte x <read=readNorTan>;
    byte y <read=readNorTan>;
    byte z <read=readNorTan>;
    byte w <read=readNorTan>;
};
struct Color{
    ubyte r <bgcolor=0x111199,fgcolor=0x0000FF>;
	ubyte g <bgcolor=0x119911,fgcolor=0x00FF00>;
	ubyte b <bgcolor=0x991111,fgcolor=0xFF0000>;
	ubyte a <bgcolor=0x111111,fgcolor=0xAAAAAA>;
};
struct Matrix{
    float row0[4];
    float row1[4];
    float row2[4];
    float row3[4];
}; 
string readMatrix(Matrix &m){
    string s;
    SPrintf( s, "%6.2f,%6.2f,%6.2f,%6.2f | %6.2f,%6.2f,%6.2f,%6.2f | %6.2f,%6.2f,%6.2f,%6.2f | %6.2f,%6.2f,%6.2f,%6.2f",
     m.row0[0],m.row0[1],m.row0[2],m.row0[3],
     m.row1[0],m.row1[1],m.row1[2],m.row1[3],
     m.row2[0],m.row2[1],m.row2[2],m.row2[3],
     m.row3[0],m.row3[1],m.row3[2],m.row3[3]);
    return s;
}

struct Header{
    char    FileType[4] <name="File Type">; //Please do not modify this value or the model cannot be loaded.
    ushort  Version; //Please do not modify this value or the model cannot be loaded.
    
    ushort  boneCount;
    ushort  meshCount;
    ushort  materialCount;
    uint    vertexCount;
    uint    faceCount;
    uint    unkn1;  
    uint64  vertexBufferSize;
    uint  groupCount;
    FSkip(4);
    uint64  timeStamp;

    uint64  boneOffset <format=hex>;
    uint64  groupOffset <format=hex>;
    uint64  materialOffset <format=hex>;
    uint64  meshOffset <format=hex>;
    uint64  vertexOffset <format=hex>;
    uint64  faceOffset <format=hex>;
    uint64  vertexRemapOffset <format=hex>;
    uint64  unknOffset <format=hex>;
    Sphere  sphere <name="boundingSphere", bgcolor=0xaa56ff, read=readSphere>;
    Box box <name="boundingBox", bgcolor=0x56aaff, read=readBox>;
    float   unkn2;
    ushort  unkn3;
    ushort  lodCount <bgcolor=0x5656ff>;
    float   unkn4[22];
    ubyte   unkn5[64];

};

FSeek(0);
Header header <name="Header", bgcolor=0x93671a, read=readFileHeader>;
string readFileHeader(Header &h){
    string s;
    SPrintf( s, "bone: %d    mesh: %d    material: %d    vertex: %u    face: %u    group: %u    lod: %d", 
            h.boneCount, h.meshCount, h.materialCount, h.vertexCount, h.faceCount/3, h.groupCount, h.lodCount);
    return s;
}

struct BoneInfo{
    ushort  boneFunction <bgcolor=0x5656ff>;
    ubyte   boneParent;
    ubyte   boneSymmetry;
    float   boneUnkn;
    float   boneLength;
    Vec3    vec3 <name="bonePosition">;  
};

if (header.boneOffset && header.boneCount) {
    FSeek(header.boneOffset);
    struct{
        struct{
            for(i = 0; i < header.boneCount; i++){
                BoneInfo boneinfo <name="BoneInfo", read=readBoneInfo>; 
            };          
        }BoneInfos <name="BoneInfos", bgcolor=0x263f2a>;
        struct{
            for(i = 0; i < header.boneCount; i++){
                Matrix localmatrix <name="LocalMatrix", read=readMatrix>; 
            };          
        }LocalMatrixs <name="LocalMatrixs", bgcolor=0x6060ff>;
        struct{
            for(i = 0; i < header.boneCount; i++){
                Matrix worldmatrix <name="worldMatrix", read=readMatrix>; 
            };          
        }WorldMatrixs <name="WorldMatrixs", bgcolor=0xff6060>;
        struct{
            for(i = 0; i < 512; i++){
                ubyte   remapID; 
            };          
        }RemapTable <name="RemapTable", bgcolor=0x60ff60>;
    }Bone <name="Bones">;
}

string readBoneInfo(BoneInfo &bi){
    string s;
    SPrintf( s, "function: %03d    parent: %03d    symmetry: %03d    length: %6.2f    position: %6.2f,%6.2f,%6.2f", 
            bi.boneFunction, bi.boneParent, bi.boneSymmetry, bi.boneLength, bi.vec3.x, bi.vec3.y, bi.vec3.z);
    return s;
}

struct MeshGroup{
    uint  groupID <bgcolor=0x5656ff>;
    FSkip(12);
    Sphere  sphere <name="groupSphere", bgcolor=0xaa56ff, read=readSphere>;
};

if (header.groupOffset && header.groupCount) {
    FSeek(header.groupOffset);
    struct{
        for(i = 0; i < header.groupCount; i++){
            MeshGroup meshgroup <name="Group", read=readMeshGroup>; 
        };          
    }Groups <name="Groups">;

}

string readMeshGroup(MeshGroup &mg){
    string s;
    SPrintf( s, "groupID: %03u    x: %6.2f    y: %6.2f    z: %6.2f    r: %6.2f", 
            mg.groupID, mg.sphere.x, mg.sphere.y, mg.sphere.z, mg.sphere.r);
    return s;
} 
      

struct MaterialName{
    char  name[128];
};

if (header.materialOffset && header.materialCount) {
    FSeek(header.materialOffset);
    struct{
        for(i = 0; i < header.materialCount; i++){
            //char  materialName[128];
            MaterialName materialName <name="MaterialName", read=readMaterialName>; 
        };          
    }Materials <name="Materials", bgcolor=0xcc00cc>;

}

string readMaterialName(MaterialName &mn){
    string s;
    SPrintf( s, "%s", mn.name);
    return s;
}

enum <uint32> BlockType {
    IANonSkin1UV = 2807493369,
    IANonSkin2UV = 2769308832,
    IANonSkin1UVColor = 2173240540,
    IANonSkin2UVColor = 252052287,
    IASkin4wt1UV = 4130816028,
    IASkin4wt2UV = 4101111365,
    IASkin4wt1UVColor = 1014171488,
    IASkin4wt2UVColor = 3002859651,
    IASkin8wt1UV = 2180350055,
    IASkin8wt2UV = 2209562174,
    IASkin8wt1UVColor = 912889255,
    IASkin8wt2UVColor = 3102118468,
    IASkin4wt1UVRcn = 3592044045,
    IASkin4wt2UVRcn = 1351503011,
    IASkin4wt1UVColorRcn = 1165554616, 
    IASkin4wt2UVColorRcn = 3701118393,
    IASkin8wt1UVRcn = 808373529,
    IASkin8wt2UVRcn = 3065692087,
    IASkin8wt1UVColorRcn = 1871536789,
    IASkin8wt2UVColorRcn = 4134470804,
    IADevelopPrim2D = 3993480186,
    IADevelopPrimImage2D = 1139705668,
    IADevelopPrim3D = 4145846971,
    IADevelopPos3UV1 = 2281592594,
    IASystemCopy = 4289380069,
    IASystemClear = 3839359605,
    IAFilter = 2279177237,
    IAFilter2 = 2777508887,
    IADecal = 2767991478,
    IADecal2 = 3933321995,
    IASea = 55792455,
    IAWaterWave = 3658059176,
    IAPosOnly = 2337935659,
    IA_AmbientOccluder = 3143073532,
    IA_SnowShoveler = 2633253930,
    IA_SnowShovelerWithTex = 2744022753,
    IA_SnowShovelerWithNormal = 619199677,
    IARibbon = 151265452,
    IARibbonBlade = 3853588429,
    IAPrimDebug3D = 3478476201,
    IAPrimDebugFont2D = 1866325959,
    IAGUI = 4069508834,
    IAPrecomputedStarrySky = 1691341603,
    IANonSkin3UVColor = 3282830241,
    IANonSkin4UVColor = 3379104440,
};

string BlockTypeToString(BlockType type) {
    switch (type) {
        case IANonSkin1UV: return "IANonSkin1UV";
        case IANonSkin2UV: return "IANonSkin2UV";
        case IANonSkin1UVColor: return "IANonSkin1UVColor";
        case IANonSkin2UVColor: return "IANonSkin2UVColor";
        case IASkin4wt1UV: return "IASkin4wt1UV";
        case IASkin4wt2UV: return "IASkin4wt2UV";
        case IASkin4wt1UVColor: return "IASkin4wt1UVColor";
        case IASkin4wt2UVColor: return "IASkin4wt2UVColor";
        case IASkin8wt1UV: return "IASkin8wt1UV";
        case IASkin8wt2UV: return "IASkin8wt2UV";
        case IASkin8wt1UVColor: return "IASkin8wt1UVColor";
        case IASkin8wt2UVColor: return "IASkin8wt2UVColor";
        case IASkin4wt1UVRcn: return "IASkin4wt1UVRcn";
        case IASkin4wt2UVRcn: return "IASkin4wt2UVRcn";
        case IASkin4wt1UVColorRcn: return "IASkin4wt1UVColorRcn";
        case IASkin4wt2UVColorRcn: return "IASkin4wt2UVColorRcn";
        case IASkin8wt1UVRcn: return "IASkin8wt1UVRcn";
        case IASkin8wt2UVRcn: return "IASkin8wt2UVRcn";
        case IASkin8wt1UVColorRcn: return "IASkin8wt1UVColorRcn";
        case IASkin8wt2UVColorRcn: return "IASkin8wt2UVColorRcn";
        case IADevelopPrim2D: return "IADevelopPrim2D";
        case IADevelopPrimImage2D: return "IADevelopPrimImage2D";
        case IADevelopPrim3D: return "IADevelopPrim3D";
        case IADevelopPos3UV1: return "IADevelopPos3UV1";
        case IASystemCopy: return "IASystemCopy";
        case IASystemClear: return "IASystemClear";
        case IAFilter: return "IAFilter";
        case IAFilter2: return "IAFilter2";
        case IADecal: return "IADecal";
        case IADecal2: return "IADecal2";
        case IASea: return "IASea";
        case IAWaterWave: return "IAWaterWave";
        case IAPosOnly: return "IAPosOnly";
        case IA_AmbientOccluder: return "IA_AmbientOccluder";
        case IA_SnowShoveler: return "IA_SnowShoveler";
        case IA_SnowShovelerWithTex: return "IA_SnowShovelerWithTex";
        case IA_SnowShovelerWithNormal: return "IA_SnowShovelerWithNormal";
        case IARibbon: return "IARibbon";
        case IARibbonBlade: return "IARibbonBlade";
        case IAPrimDebug3D: return "IAPrimDebug3D";
        case IAPrimDebugFont2D: return "IAPrimDebugFont2D";
        case IAGUI: return "IAGUI";
        case IAPrecomputedStarrySky: return "IAPrecomputedStarrySky";
        case IANonSkin3UVColor: return "IANonSkin3UVColor";
        case IANonSkin4UVColor: return "IANonSkin4UVColor";
        default: return "Invalid Type";
    }
}
ubyte BlockTypeToSize(BlockType type) {
    switch (type) {
        case IANonSkin1UV: return 24;
        case IANonSkin2UV: return 28;
        case IANonSkin1UVColor: return 28;
        case IANonSkin2UVColor: return 32;
        case IASkin4wt1UV: return 32;
        case IASkin4wt2UV: return 36;
        case IASkin4wt1UVColor: return 36;
        case IASkin4wt2UVColor: return 40;
        case IASkin8wt1UV: return 40;
        case IASkin8wt2UV: return 44;
        case IASkin8wt1UVColor: return 44;
        case IASkin8wt2UVColor: return 48;
        case IASkin4wt1UVRcn: return 0;
        case IASkin4wt2UVRcn: return 0;
        case IASkin4wt1UVColorRcn: return 0;
        case IASkin4wt2UVColorRcn: return 0;
        case IASkin8wt1UVRcn: return 0;
        case IASkin8wt2UVRcn: return 0;
        case IASkin8wt1UVColorRcn: return 0;
        case IASkin8wt2UVColorRcn: return 0;
        case IADevelopPrim2D: return 0;
        case IADevelopPrimImage2D: return 0;
        case IADevelopPrim3D: return 0;
        case IADevelopPos3UV1: return 0;
        case IASystemCopy: return 0;
        case IASystemClear: return 0;
        case IAFilter: return 0;
        case IAFilter2: return 0;
        case IADecal: return 0;
        case IADecal2: return 0;
        case IASea: return 0;
        case IAWaterWave: return 0;
        case IAPosOnly: return 0;
        case IA_AmbientOccluder: return 0;
        case IA_SnowShoveler: return 0;
        case IA_SnowShovelerWithTex: return 0;
        case IA_SnowShovelerWithNormal: return 0;
        case IARibbon: return 0;
        case IARibbonBlade: return 0;
        case IAPrimDebug3D: return 0;
        case IAPrimDebugFont2D: return 0;
        case IAGUI: return 0;
        case IAPrecomputedStarrySky: return 0;
        case IANonSkin3UVColor: return 36;
        case IANonSkin4UVColor: return 40;
        default: return 0;
    }
}
/*
typedef struct {
	ubyte lod0_display_enable : 1;
	ubyte lod1_display_enable : 1; 
	ubyte lod2_display_enable : 1; 
	ubyte lod3_display_enable : 1; 
    ubyte lod4_display_enable : 1; 
    ubyte lod5_display_enable : 1; 
    ubyte lod6_display_enable : 1; 
    ubyte lod7_display_enable : 1; 
    ubyte lod8_display_enable : 1; 
    ubyte lod9_display_enable : 1; 
    ubyte lod10_display_enable : 1; 
    ubyte lod11_display_enable : 1; 
    ubyte lod12_display_enable : 1; 
    ubyte lod13_display_enable : 1; 
    ubyte lod14_display_enable : 1; 
    ubyte lod15_display_enable : 1; 
}LOD;
*/

string readWeight(uint w){
    string s;
    SPrintf( s, "%f    raw: %u", (w & 1023) * weightScale, w);
    return s;
}
typedef struct {
	uint weight0 : 10 <read=readWeight>;
	uint weight1 : 10 <read=readWeight>; 
	uint weight2 : 10 <read=readWeight>; 
	uint end : 2; 
}WEIGHT;

string readExtendWeight(ubyte w){
    string s;
    SPrintf( s, "%f    raw: %d", (w & 255) * weightScale, w);
    return s;
}
typedef struct {
	ubyte weight3 <read=readExtendWeight>;
	ubyte weight4 <read=readExtendWeight>; 
	ubyte weight5 <read=readExtendWeight>; 
	ubyte weight6 <read=readExtendWeight>; 
}EXTENDWEIGHT;

void calculateWeight(WEIGHT &w, EXTENDWEIGHT &ew, float weight[8], ubyte extend) {
    for (k = 0; k < 8; k++) {weight[k] = 0.0;}
    weight[0] = (w.weight0 & 1023) * weightScale;
    if (weight[0] == 1.0) {return;}

    local float runningSum;
    runningSum = weight[0];
    weight[1] = (w.weight1 & 1023) * weightScale;
    runningSum += weight[1];
    if (runningSum >= 1.0) {return;}

    weight[2] = (w.weight2 & 1023) * weightScale;
    runningSum += weight[2];
    if (runningSum >= 1.0) {return;}
    if(extend == 0){
        //weight[3] = 1.0 - weight[0] - weight[1] - weight[2];
        weight[3] = Max(0.0, 1.0 - runningSum);
    }
    else if(extend == 1){
        weight[3] = (ew.weight3 & 255) * weightScale;
        runningSum += weight[3];
        if (runningSum >= 1.0) {return;}

        weight[4] = (ew.weight4 & 255) * weightScale;
        runningSum += weight[4];
        if (runningSum >= 1.0) {return;}

        weight[5] = (ew.weight5 & 255) * weightScale;
        runningSum += weight[5];
        if (runningSum >= 1.0) {return;}

        weight[6] = (ew.weight6 & 255) * weightScale;
        runningSum += weight[6];
        if (runningSum >= 1.0) {return;}
        
        weight[7] = Max(0.0, 1.0 - runningSum);
    }
}

struct IANonSkin1UV{
    Vec3    position <name="position">;;
    NorTan    normal <name="normal">;
    NorTan    tangent <name="tangent">;
    UV  uv <name="uv">;
};
string readIANonSkin1UV(IANonSkin1UV &vb){
    string s;
    SPrintf( s, "position: %6.2f,%6.2f,%6.2f    normal: %6.2f,%6.2f,%6.2f    uv: %6.2f,%6.2f", 
            vb.pos.x, vb.pos.y, vb.pos.z, vb.nor.x*scale, vb.nor.y*scale, vb.nor.z*scale,
            vb.uv.x, vb.uv.y);
    return s;
}
struct IANonSkin2UV{
    Vec3    position <name="position">;;
    NorTan    normal <name="normal">;
    NorTan    tangent <name="tangent">;
    UV  uv <name="uv">;
    UV  uv2 <name="uv2">;
};
string readIANonSkin2UV(IANonSkin2UV &vb){
    string s;
    SPrintf( s, "position: %6.2f,%6.2f,%6.2f    normal: %6.2f,%6.2f,%6.2f    uv: %6.2f,%6.2f    uv2: %6.2f,%6.2f", 
            vb.pos.x, vb.pos.y, vb.pos.z, vb.nor.x*scale, vb.nor.y*scale, vb.nor.z*scale,
            vb.uv.x, vb.uv.y, vb.uv2.x, vb.uv2.y);
    return s;
}
struct IANonSkin1UVColor{
    Vec3    position <name="position">;;
    NorTan    normal <name="normal">;
    NorTan    tangent <name="tangent">;
    UV  uv <name="uv">;
    Color   color <name="color">;
};
string readIANonSkin1UVColor(IANonSkin1UVColor &vb){
    string s;
    SPrintf( s, "position: %6.2f,%6.2f,%6.2f    normal: %6.2f,%6.2f,%6.2f    uv: %6.2f,%6.2f    color: %d,%d,%d,%d", 
            vb.pos.x, vb.pos.y, vb.pos.z, vb.nor.x*scale, vb.nor.y*scale, vb.nor.z*scale,
            vb.uv.x, vb.uv.y, vb.color.r, vb.color.g, vb.color.b, vb.color.a);
    return s;
}
struct IANonSkin2UVColor{
    Vec3    position <name="position">;;
    NorTan    normal <name="normal">;
    NorTan    tangent <name="tangent">;
    UV  uv <name="uv">;
    UV  uv2 <name="uv2">;
    Color   color <name="color">;
};
string readIANonSkin2UVColor(IANonSkin2UVColor &vb){
    string s;
    SPrintf( s, "position: %6.2f,%6.2f,%6.2f    normal: %6.2f,%6.2f,%6.2f    uv: %6.2f,%6.2f    uv2: %6.2f,%6.2f    color: %d,%d,%d,%d", 
            vb.pos.x, vb.pos.y, vb.pos.z, vb.nor.x*scale, vb.nor.y*scale, vb.nor.z*scale,
            vb.uv.x, vb.uv.y, vb.uv2.x, vb.uv2.y, vb.color.r, vb.color.g, vb.color.b, vb.color.a);
    return s;
}
struct IASkin4wt1UV{
    Vec3    pos <name="position">;;
    NorTan    nor <name="normal">;
    NorTan    tan <name="tangent">;
    UV  uv <name="uv">;
    //uint    weight <name="weight">;
    WEIGHT weight <format=binary, name="baseWeight">;
    local EXTENDWEIGHT ew;
    ubyte   bone[4] <name="bone">;
};
string readIASkin4wt1UV(IASkin4wt1UV &vb){
    string s;
    float weight[8];
    calculateWeight(vb.weight, vb.ew, weight, 0);
    SPrintf( s, "position: %6.2f,%6.2f,%6.2f    normal: %6.2f,%6.2f,%6.2f    uv: %6.2f,%6.2f    weight: %6.3f,%6.3f,%6.3f,%6.3f    bone: %03d,%03d,%03d,%03d", 
            vb.pos.x, vb.pos.y, vb.pos.z, vb.nor.x*scale, vb.nor.y*scale, vb.nor.z*scale,
            vb.uv.x, vb.uv.y, weight[0], weight[1], weight[2], weight[3],
            vb.bone[0], vb.bone[1], vb.bone[2], vb.bone[3]);
    return s;
}
struct IASkin4wt2UV{
    Vec3    pos <name="position">;;
    NorTan    nor <name="normal">;
    NorTan    tan <name="tangent">;
    UV  uv <name="uv">;
    UV  uv2 <name="uv2">;
    //uint    weight <name="weight">;
    WEIGHT weight <format=binary, name="baseWeight">;
    local EXTENDWEIGHT ew;
    ubyte   bone[4] <name="bone">;
};
string readIASkin4wt2UV(IASkin4wt2UV &vb){
    string s;
    float weight[8];
    calculateWeight(vb.weight, vb.ew, weight, 0);
    SPrintf( s, "position: %6.2f,%6.2f,%6.2f    normal: %6.2f,%6.2f,%6.2f    uv: %6.2f,%6.2f    uv2: %6.2f,%6.2f    weight: %6.3f,%6.3f,%6.3f,%6.3f    bone: %03d,%03d,%03d,%03d", 
            vb.pos.x, vb.pos.y, vb.pos.z, vb.nor.x*scale, vb.nor.y*scale, vb.nor.z*scale,
            vb.uv.x, vb.uv.y, vb.uv2.x, vb.uv2.y, weight[0], weight[1], weight[2], weight[3], 
            vb.bone[0], vb.bone[1], vb.bone[2], vb.bone[3]);
    return s;
}
struct IASkin4wt1UVColor{
    Vec3    pos <name="position">;;
    NorTan    nor <name="normal">;
    NorTan    tan <name="tangent">;
    UV  uv <name="uv">;
    //uint    weight <name="weight">;
    WEIGHT weight <format=binary, name="baseWeight">;
    local EXTENDWEIGHT ew;
    ubyte   bone[4] <name="bone">;
    Color   color <name="color">;
};
string readIASkin4wt1UVColor(IASkin4wt1UVColor &vb){
    string s;
    float weight[8];
    calculateWeight(vb.weight, vb.ew, weight, 0);
    SPrintf( s, "position: %6.2f,%6.2f,%6.2f    normal: %6.2f,%6.2f,%6.2f    uv: %6.2f,%6.2f    weight: %6.3f,%6.3f,%6.3f,%6.3f    bone: %03d,%03d,%03d,%03d    color: %d,%d,%d,%d", 
            vb.pos.x, vb.pos.y, vb.pos.z, vb.nor.x*scale, vb.nor.y*scale, vb.nor.z*scale,
            vb.uv.x, vb.uv.y, weight[0], weight[1], weight[2], weight[3], 
            vb.bone[0], vb.bone[1], vb.bone[2], vb.bone[3],
            vb.color.r, vb.color.g, vb.color.b, vb.color.a);
    return s;
}
struct IASkin4wt2UVColor{
    Vec3    pos <name="position">;;
    NorTan    nor <name="normal">;
    NorTan    tan <name="tangent">;
    UV  uv <name="uv">;
    UV  uv2 <name="uv2">;
    //uint    weight <name="weight">;
    WEIGHT weight <format=binary, name="baseWeight">;
    local EXTENDWEIGHT ew;
    ubyte   bone[4] <name="bone">;
    Color   color <name="color">;
};
string readIASkin4wt2UVColor(IASkin4wt2UVColor &vb){
    string s;
    float weight[8];
    calculateWeight(vb.weight, vb.ew, weight, 0);
    SPrintf( s, "position: %6.2f,%6.2f,%6.2f    normal: %6.2f,%6.2f,%6.2f    uv: %6.2f,%6.2f    uv2: %6.2f,%6.2f    weight: %6.3f,%6.3f,%6.3f,%6.3f    bone: %03d,%03d,%03d,%03d    color: %d,%d,%d,%d", 
            vb.pos.x, vb.pos.y, vb.pos.z, vb.nor.x*scale, vb.nor.y*scale, vb.nor.z*scale,
            vb.uv.x, vb.uv.y, vb.uv2.x, vb.uv2.y, weight[0], weight[1], weight[2], weight[3],  
            vb.bone[0], vb.bone[1], vb.bone[2], vb.bone[3],
            vb.color.r, vb.color.g, vb.color.b, vb.color.a);
    return s;
}
struct IASkin8wt1UV{
    Vec3    pos <name="position">;;
    NorTan    nor <name="normal">;
    NorTan    tan <name="tangent">;
    UV  uv <name="uv">;
    //uint    weight[2] <name="weight">;
    WEIGHT weight <format=binary, name="baseWeight">;
    EXTENDWEIGHT ew <name="extendWeight">;
    ubyte   bone[8] <name="bone">;
};
string readIASkin8wt1UV(IASkin8wt1UV &vb){
    string s;
    float weight[8];
    calculateWeight(vb.weight, vb.ew, weight, 1);
    SPrintf( s, "position: %6.2f,%6.2f,%6.2f    normal: %6.2f,%6.2f,%6.2f    uv: %6.2f,%6.2f    weight: %6.3f,%6.3f,%6.3f,%6.3f,%6.3f,%6.3f,%6.3f,%6.3f   bone: %03d,%03d,%03d,%03d,%03d,%03d,%03d,%03d", 
            vb.pos.x, vb.pos.y, vb.pos.z, vb.nor.x*scale, vb.nor.y*scale, vb.nor.z*scale, vb.uv.x, vb.uv.y, 
            weight[0], weight[1], weight[2], weight[3], weight[4], weight[5], weight[6], weight[7],
            vb.bone[0], vb.bone[1], vb.bone[2], vb.bone[3], vb.bone[4], vb.bone[5], vb.bone[6], vb.bone[7]);
    return s;
}
struct IASkin8wt2UV{
    Vec3    pos <name="position">;;
    NorTan    nor <name="normal">;
    NorTan    tan <name="tangent">;
    UV  uv <name="uv">;
    UV  uv2 <name="uv2">;
    //uint    weight[2] <name="weight">;
    WEIGHT weight <format=binary, name="baseWeight">;
    EXTENDWEIGHT ew <name="extendWeight">;
    ubyte   bone[8] <name="bone">;
};
string readIASkin8wt2UV(IASkin8wt2UV &vb){
    string s;
    float weight[8];
    calculateWeight(vb.weight, vb.ew, weight, 1);
    SPrintf( s, "position: %6.2f,%6.2f,%6.2f    normal: %6.2f,%6.2f,%6.2f    uv: %6.2f,%6.2f    uv2: %6.2f,%6.2f    weight: %6.3f,%6.3f,%6.3f,%6.3f,%6.3f,%6.3f,%6.3f,%6.3f    bone: %03d,%03d,%03d,%03d,%03d,%03d,%03d,%03d", 
            vb.pos.x, vb.pos.y, vb.pos.z, vb.nor.x*scale, vb.nor.y*scale, vb.nor.z*scale,
            vb.uv.x, vb.uv.y, vb.uv2.x, vb.uv2.y, 
            weight[0], weight[1], weight[2], weight[3], weight[4], weight[5], weight[6], weight[7],
            vb.bone[0], vb.bone[1], vb.bone[2], vb.bone[3], vb.bone[4], vb.bone[5], vb.bone[6], vb.bone[7]);
    return s;
}
struct IASkin8wt1UVColor{
    Vec3    pos <name="position">;;
    NorTan    nor <name="normal">;
    NorTan    tan <name="tangent">;
    UV  uv <name="uv">;
    //uint    weight[2] <name="weight">;
    WEIGHT weight <format=binary, name="baseWeight">;
    EXTENDWEIGHT ew <name="extendWeight">;
    ubyte   bone[8] <name="bone">;
    Color   color <name="color">;
};
string readIASkin8wt1UVColor(IASkin8wt1UVColor &vb){
    string s;
    float weight[8];
    calculateWeight(vb.weight, vb.ew, weight, 1);
    SPrintf( s, "position: %6.2f,%6.2f,%6.2f    normal: %6.2f,%6.2f,%6.2f    uv: %6.2f,%6.2f    weight: %6.3f,%6.3f,%6.3f,%6.3f,%6.3f,%6.3f,%6.3f,%6.3f    bone: %03d,%03d,%03d,%03d,%03d,%03d,%03d,%03d    color: %d,%d,%d,%d", 
            vb.pos.x, vb.pos.y, vb.pos.z, vb.nor.x*scale, vb.nor.y*scale, vb.nor.z*scale, vb.uv.x, vb.uv.y, 
            weight[0], weight[1], weight[2], weight[3], weight[4], weight[5], weight[6], weight[7],
            vb.bone[0], vb.bone[1], vb.bone[2], vb.bone[3], vb.bone[4], vb.bone[5], vb.bone[6], vb.bone[7],
            vb.color.r, vb.color.g, vb.color.b, vb.color.a);
    return s;
}
struct IASkin8wt2UVColor{
    Vec3    pos <name="position">;;
    NorTan    nor <name="normal">;
    NorTan    tan <name="tangent">;
    UV  uv <name="uv">;
    UV  uv2 <name="uv2">;
    //uint    weight[2] <name="weight">;
    WEIGHT weight <format=binary, name="baseWeight">;
    EXTENDWEIGHT ew <name="extendWeight">;
    ubyte   bone[8] <name="bone">;
    Color   color <name="color">;
};
string readIASkin8wt2UVColor(IASkin8wt2UVColor &vb){
    string s;
    float weight[8];
    calculateWeight(vb.weight, vb.ew, weight, 1);
    SPrintf( s, "position: %6.2f,%6.2f,%6.2f    normal: %6.2f,%6.2f,%6.2f    uv: %6.2f,%6.2f    uv2: %6.2f,%6.2f    weight: %6.3f,%6.3f,%6.3f,%6.3f,%6.3f,%6.3f,%6.3f,%6.3f    bone: %03d,%03d,%03d,%03d,%03d,%03d,%03d,%03d    color: %d,%d,%d,%d", 
            vb.pos.x, vb.pos.y, vb.pos.z, vb.nor.x*scale, vb.nor.y*scale, vb.nor.z*scale, vb.uv.x, vb.uv.y, vb.uv2.x, vb.uv2.y, 
            weight[0], weight[1], weight[2], weight[3], weight[4], weight[5], weight[6], weight[7],
            vb.bone[0], vb.bone[1], vb.bone[2], vb.bone[3], vb.bone[4], vb.bone[5], vb.bone[6], vb.bone[7],
            vb.color.r, vb.color.g, vb.color.b, vb.color.a);
    return s;
}
struct IANonSkin3UVColor{
    Vec3    position <name="position">;;
    NorTan    normal <name="normal">;
    NorTan    tangent <name="tangent">;
    UV  uv <name="uv">;
    UV  uv2 <name="uv2">;
    UV  uv3 <name="uv3">;
    Color   color <name="color">;
};
string readIANonSkin3UVColor(IANonSkin3UVColor &vb){
    string s;
    SPrintf( s, "position: %6.2f,%6.2f,%6.2f    normal: %6.2f,%6.2f,%6.2f    uv: %6.2f,%6.2f    uv2: %6.2f,%6.2f    uv3: %6.2f,%6.2f    color: %d,%d,%d,%d", 
            vb.pos.x, vb.pos.y, vb.pos.z, vb.nor.x*scale, vb.nor.y*scale, vb.nor.z*scale,
            vb.uv.x, vb.uv.y, vb.uv2.x, vb.uv2.y, vb.uv3.x, vb.uv3.y, 
            vb.color.r, vb.color.g, vb.color.b, vb.color.a);
    return s;
}
struct IANonSkin4UVColor{
    Vec3    position <name="position">;;
    NorTan    normal <name="normal">;
    NorTan    tangent <name="tangent">;
    UV  uv <name="uv">;
    UV  uv2 <name="uv2">;
    UV  uv3 <name="uv3">;
    UV  uv4 <name="uv4">;
    Color   color <name="color">;
};
string readIANonSkin4UVColor(IANonSkin4UVColor &vb){
    string s;
    SPrintf( s, "position: %6.2f,%6.2f,%6.2f    normal: %6.2f,%6.2f,%6.2f    uv: %6.2f,%6.2f    uv2: %6.2f,%6.2f    uv3: %6.2f,%6.2f    uv4: %6.2f,%6.2f    color: %d,%d,%d,%d", 
            vb.pos.x, vb.pos.y, vb.pos.z, vb.nor.x*scale, vb.nor.y*scale, vb.nor.z*scale,
            vb.uv.x, vb.uv.y, vb.uv2.x, vb.uv2.y, vb.uv3.x, vb.uv3.y, vb.uv4.x, vb.uv4.y,
            vb.color.r, vb.color.g, vb.color.b, vb.color.a);
    return s;
}
struct FaceInfo{
    ushort  index0;
    ushort  index1;
    ushort  index2;
};
string readFaceInfo(FaceInfo &fb){
    string s;
    SPrintf( s, "index: %d,%d,%d", 
            fb.index0, fb.index1, fb.index2);
    return s;
}
struct BBoxInfo{
    ushort  boneID;
    FSkip(14);
    Sphere  sphere <name="Sphere", bgcolor=0xaa56ff, read=readSphere>;
    Box box <name="AABB", bgcolor=0x56aaff, read=readBox>;
    Matrix OBBMatrix <name="OBB_Matrix", bgcolor=0xffaa56, read=readMatrix>; 
    Vec4 vec4 <name="OBB_Vector", bgcolor=0xffaa56, read=readVec4>; 
};
string readBBoxInfo(BBoxInfo &bb){
    string s;
    SPrintf( s, "boneID: %03d", 
            bb.boneID);
    return s;
}
typedef struct {
	ushort unkn1 : 1;
    ushort unkn2 : 1;
    ushort unkn3 : 1;
	ushort weightCount : 13; 
}WEIGHTDYNAMICS;

string readWeightDynamics(WEIGHTDYNAMICS &wd){
    string s;
    ushort temp;
    temp = wd.weightCount;
    if(wd.weightCount > 8){temp = 8;}
    SPrintf( s, "weightCount: %u    raw: %u", temp, wd.weightCount);
    return s;
}
struct MeshInfo{
    ushort  shadowFlag;
    ushort  vertexCount;
    ushort  groupID;
    ushort  materialID;
    ushort  lod <bgcolor=0x5656ff>;
    //LOD lod <format=binary, name="meshLOD">;
    ushort  unkn1;
    //ushort  weightDynamics <bgcolor=0x5656ff>;
    WEIGHTDYNAMICS weightDynamics <format=binary, name="weightDynamics", bgcolor=0x5656ff, read=readWeightDynamics>;
    ubyte   blockSize;
    ubyte   renderMode;
    uint    vertexSub;
    uint    vertexOffset;
    //uint    blockType <bgcolor=0x5656ff>;
    BlockType blockType <name="blockType", bgcolor=0x5656ff>;
    uint    beforeFaceCount;
    uint    faceCount;
    uint    vertexBase;
    ubyte   unkn2;
    ubyte   bboxCount;
    ushort  meshID;
    ushort  vertexMinID;
    ushort  vertexMaxID;
    FSkip(8);
    ubyte  unkn3[4];
    uint  beforeVertexCount <bgcolor=0xaa56ff>;
    //ubyte  unkn4[16];
    FSkip(16);
    local ubyte  valid = 1;
    
    local string  blockTypeName = BlockTypeToString(blockType);
    local ubyte blockTypeSize = BlockTypeToSize(blockType);
    if (lod != 0 && blockTypeName != "Invalid Type" && blockSize == blockTypeSize && blockTypeSize != 0
        && faceCount % 3 == 0 && vertexCount <= faceCount && materialID < header.materialCount) {
        //valid = 1;
        //validMeshCount += 1;
        oriOffset = FTell();
        FSeek(header.vertexOffset + vertexOffset + blockSize * (vertexSub + vertexBase));

        if (blockTypeName == "IANonSkin1UV") {
            IANonSkin1UV vertexInfo[vertexCount] <name="vertexInfo", bgcolor=0x6060ff, read=readIANonSkin1UV>; 
        }
        else if (blockTypeName == "IANonSkin2UV") {
            IANonSkin2UV vertexInfo[vertexCount] <name="vertexInfo", bgcolor=0x6060ff, read=readIANonSkin2UV>; 
        }
        else if (blockTypeName == "IANonSkin1UVColor") {
            IANonSkin1UVColor vertexInfo[vertexCount] <name="vertexInfo", bgcolor=0x6060ff, read=readIANonSkin1UVColor>; 
        }
        else if (blockTypeName == "IANonSkin2UVColor") {
            IANonSkin2UVColor vertexInfo[vertexCount] <name="vertexInfo", bgcolor=0x6060ff, read=readIANonSkin2UVColor>; 
        }
        else if(blockTypeName == "IASkin4wt1UV") {
            IASkin4wt1UV vertexInfo[vertexCount] <name="vertexInfo", bgcolor=0x6060ff, read=readIASkin4wt1UV>; 
        }
        else if(blockTypeName == "IASkin4wt2UV") {
            IASkin4wt2UV vertexInfo[vertexCount] <name="vertexInfo", bgcolor=0x6060ff, read=readIASkin4wt2UV>; 
        }
        else if(blockTypeName == "IASkin4wt1UVColor") {
            IASkin4wt1UVColor vertexInfo[vertexCount] <name="vertexInfo", bgcolor=0x6060ff, read=readIASkin4wt1UVColor>; 
        }
        else if(blockTypeName == "IASkin4wt2UVColor") {
            IASkin4wt2UVColor vertexInfo[vertexCount] <name="vertexInfo", bgcolor=0x6060ff, read=readIASkin4wt2UVColor>; 
        }
        else if(blockTypeName == "IASkin8wt1UV") {
            IASkin8wt1UV vertexInfo[vertexCount] <name="vertexInfo", bgcolor=0x6060ff, read=readIASkin8wt1UV>; 
        }
        else if(blockTypeName == "IASkin8wt2UV") {
            IASkin8wt2UV vertexInfo[vertexCount] <name="vertexInfo", bgcolor=0x6060ff, read=readIASkin8wt2UV>; 
        }
        else if(blockTypeName == "IASkin8wt1UVColor") {
            IASkin8wt1UVColor vertexInfo[vertexCount] <name="vertexInfo", bgcolor=0x6060ff, read=readIASkin8wt1UVColor>; 
        }
        else if(blockTypeName == "IASkin8wt2UVColor") {
            IASkin8wt2UVColor vertexInfo[vertexCount] <name="vertexInfo", bgcolor=0x6060ff, read=readIASkin8wt2UVColor>; 
        }
        else if (blockTypeName == "IANonSkin3UVColor") {
            IANonSkin3UVColor vertexInfo[vertexCount] <name="vertexInfo", bgcolor=0x6060ff, read=readIANonSkin3UVColor>; 
        }
        else if (blockTypeName == "IANonSkin4UVColor") {
            IANonSkin4UVColor vertexInfo[vertexCount] <name="vertexInfo", bgcolor=0x6060ff, read=readIANonSkin4UVColor>; 
        }
        //else {FSeek(oriOffset);}         
    
        FSeek(header.faceOffset + 2 * beforeFaceCount);
        FaceInfo faceInfo[faceCount / 3] <name="faceInfo", bgcolor=0xff6060, read=readFaceInfo>; 

        for (j = 0; j < faceCount / 3; j++) {
            if (faceInfo[j].index0 < vertexSub || faceInfo[j].index0 >= vertexSub + vertexCount ||
                faceInfo[j].index1 < vertexSub || faceInfo[j].index1 >= vertexSub + vertexCount ||
                faceInfo[j].index2 < vertexSub || faceInfo[j].index2 >= vertexSub + vertexCount) {
                valid = 0; 
                break;     
            }
        }
        FSeek(oriOffset);
        if (valid) {validMeshCount += 1;}
    }
    else {valid = 0;}
};


if (header.meshOffset && header.meshCount) {
    FSeek(header.meshOffset);
    struct{
        struct{
            for(i = 0; i < header.meshCount; i++){
                FSeek(header.meshOffset + i * 80);
                MeshInfo meshinfo <name="MeshInfo", bgcolor=0x93671a, read=readMeshInfo>; 
            };          
        }MeshInfos <name="MeshInfos", bgcolor=0x263f2a>;
        struct{
            uint    count;
            if(count){
                for(i = 0; i < count; i++){
                    BBoxInfo bboxinfo <name="BBoxInfo", read=readBBoxInfo>; 
                }; 
            }         
        }BBoxInfos <name="BBoxInfos", bgcolor=0x263f2a>;
    }Mesh <name="Meshs">;
}

const ubyte printType = 0; //修改此值以改变readMeshInfo的打印类型
string readMeshInfo(MeshInfo &mi){
    string s;
    string mn;

    if(mi.materialID < header.materialCount){
        mn = Materials.materialName[mi.materialID].name;
    }
    if (mi.valid) {
        if (printType == 0) {
            SPrintf( s, "lod: %05d    vertex: %d    face: %u    block: %s    material: %s    groupID: %03d    shadowFlag: %03d    renderMode: %03d    meshID: %03d", 
                    mi.lod, mi.vertexCount, mi.faceCount/3, BlockTypeToString(mi.blockType), mn, mi.groupID, mi.shadowFlag, mi.renderMode, mi.meshID);
        }
        else if(printType == 1) {
            SPrintf( s, "blockSize: %d    vertexCount: %d    vertexSub: %u    vertexBase: %u    vertexOffset: %u", 
                    mi.blockSize, mi.vertexCount, mi.vertexSub, mi.vertexBase, mi.vertexOffset);
        }
        else if(printType == 2) {
            SPrintf( s, "faceCount: %u    beforeFaceCount: %u    vertexCount: %d    beforeVertexCount: %u", 
                    mi.faceCount/3, mi.beforeFaceCount/3, mi.vertexCount, mi.beforeVertexCount);
        }
        else if(printType == 3) {
            SPrintf( s, "vertexCount: %d    vertexSub: %u    vertexMinID: %d    vertexMaxID: %d", 
                    mi.vertexCount, mi.vertexSub, mi.vertexMinID, mi.vertexMaxID);
        }
    }
    else {
        SPrintf(s, "invalid mesh");
    }
    return s;
}

if (header.vertexRemapOffset && header.meshCount) {
    FSeek(header.vertexRemapOffset);
    struct{
        ubyte   unkn1[4];
        uint    dataSize;
        if (dataSize) {
            uint    vertexCount[header.meshCount] <bgcolor=0xcc00cc>;
            for(i = 0; i < header.meshCount; i++){
                if (vertexCount[i]) {
                    struct{
                        ushort  index[vertexCount[i]];
                    }vertexRemap <name="vertexRemap">;
                }
            }
        }
        ubyte   unkn2[16];
    }VertexRemap <name="VertexRemap", bgcolor=0x263f2a>; //暂不清楚这个表的具体含义，猜测是平滑法向用的，因为表中有对应映射的点都在UV孤岛边界，如果不勾选自动平滑的话，边界的法向就会不一致
}

Printf("Template finished executing.\n");
Printf("Valid Mesh Count: %u / %u", validMeshCount, header.meshCount);
